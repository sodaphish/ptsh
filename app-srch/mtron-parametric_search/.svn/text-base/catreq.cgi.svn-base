#!/usr/bin/perl
# filename: catreq.cgi
# (C)opyright 2000-01, M-tron Industries, Inc., all rights reserved.
#	written by Corey J. Steele <csteele@mtron.com>
# last modified: 02/08/2001
#
# Description:  this script takes input from the catalog request form
#	and logs it to a database, and then e-mail the necessary data 
#	to a disclosed list of recipients... 
#
# 1) if you change the location of the catform.htm file, you MUST 
#	change the URL listed as $real_referer
# 2) if you want to change who gets the catalog notifications, you
# 	need to make sure their address is listed in the @recipients
#	array... and DO NOT FORGET TO PROPERLY ESCAPE THE 'AT' 
#	SYMBOL or perl will crap all over the place.
#
print "Content-type: text/html\n\n";

use CGI::Carp qw( fatalsToBrowser );
use CGI param;
use MIME::Lite;
use lib qw( lib cfg ); 
use ParseLib;
require "DSN_readwrite.pl";
require "Catreq.pl";


$date = time();
$host = $ENV{'REMOTE_ADDR'};
  $host = $ENV{'REMOTE_HOST'} if( $host eq "" );
$this_referer = $ENV{'HTTP_REFERER'}; 

$fail_url = param( "failure" );
$succ_url = param( "success" );

$last_name 	= Clean( param( "required-Last_Name" ) );
$first_name 	= Clean( param( "required-First_Name" ) );
$title		= Clean( param( "Title" ) );
$company	= Clean( param( "required-Company" ) );
$address	= Clean( param( "required-Address" ) );
$city		= Clean( param( "required-City" ) );
$state		= Clean( param( "required-State" ) );
$zip		= Clean( param( "required-Zip_Code" ) );
$country	= Clean( param( "required-Country" ) );
$email		= Clean( param( "required-E_Mail" ) );
$phone		= Clean( param( "Phone" ) );
$fax		= Clean( param( "Fax" ) );
$comments	= Clean( param( "Comments" ) );
$industry	= Clean( param( "indust" ) );
$update 	= Clean( param( "updates" ) );
push( @products, $_ ) foreach( param( "Product" ) );
if( $products == 0 ){ push( @products, param( "othprod" ) ); }

if( $this_referer ne $real_referer ){

	#
	# they aren't coming to us from the catalog request form,
	# chances are this isn't a good thing. Granted, there are 
	# ways to spoof the requesting document, but we aren't 
  	# concerned with that here -- KILL THEM!
	
	#
	# I think we should do this... but Sales thinks otherwise.  clowns.
	print "imposter! $host\n";

	FetchAndShow( $fail_url );

	# at some point, maybe we'll log these failures?

} else {

	#
	# this is a valid request, let it pas... 

	if( ValidateInput() ){

		#
		# they've got all of the required fields, lets boogy!
		RecordData(); 
		EmailData(); 
		#LogRequest();

		FetchAndShow( $succ_url );
		

	} else {

		#
		# they're missing something, STOP THEM!
		FetchAndShow( $fail_url );

	}

}

exit( 0 );


sub ValidateInput {
	
	if( $last_name eq "" || $first_name eq "" || $company eq "" || 
	$address eq "" || $city eq "" || $state eq "" || $zip eq "" || 
	$country eq "" || $email eq "" ){
		#
		# they don't have one of the required fields
		return -1;
	} else {
		return 1;
	}

}


sub Clean {

	my $return = "";
	foreach( @_ ){
		$_ =~ s/\'/\`/gi;
		$return .= "$_ ";
	}
	return $return;

}


sub RecordData {

	#
	# we're going to do two inserts here, hope they work!


	# primary insert... most likely to fail because of free-form entry boxes
	my $sqlstmt = "INSERT INTO cat_requester_address (date,host,last_name,first_name,title,company,address,city,state,zip,country,email,phone,fax,comments,industry,updates) VALUES ( '$date','$host','$last_name','$first_name','$title','$company','$address','$city','$state','$zip','$country','$email','$phone','$fax','$comments','$industry','$update')"; 
	my $stmt_h = $__dsn->prepare( $sqlstmt ) or die "Could not prepare statement: $DBI::errstr\n";
	$stmt_h->execute or die "Could not execute $sqlstmt: $DBI::errstr";

	my $request_id = GetRequestID( $date, $host );

	# products insert
	foreach( @products ){
		if( $_ ne "" ){
			my $sqlstmt2 = "INSERT INTO cat_product_interest (rid,product) VALUES ( '$request_id','$_' )";
			$stmt_h = $__dsn->prepare( $sqlstmt2 ) or die "could not prepare statement: $DBI::errstr\n";
			$stmt_h->execute or die "Could not execute $sqlstmt: $DBI::errstr"; 
		}
	}

	return;

}


sub GetRequestID {

	my $sqlstmt = "SELECT ID FROM cat_requester_address WHERE ( date='$date' AND host='$host' )"; 

	my $stmt_h = $__dsn->prepare( $sqlstmt ) or die "Could not prepare statement: $DBI::errstr\n";
	$stmt_h->execute or die "Could not execute $sqlstmt: $DBI::errstr"; 

	return $stmt_h->fetchrow();

}


sub EmailData {

	MIME::Lite->send( 'smtp', 'mail.mtron.com', Timeout => 20 )
		or die "Can't setup sendmail...";

	$date_word = `date`; chomp( $date_word );

	my $body = "date: $date_word\n-----\n$last_name, $first_name\n$title, $company\n$address\n$city, $state $zip\n$country\nphone: $phone\nfax: $fax\nemail: $email\ncomments: $comments\n---\ngenerated by Catalog Request $__Tokens{'__VERSION'}"; 

	foreach $addr ( @catreq_recipients ){
		$message = MIME::Lite->new( 
			From => "catalog\@mtron.com",
			To => "$addr",
			Subject => "Catalog Request",
			Type => "text/plain",
			Encoding => '7bit',
			Data => "$body" );
		$message->send;
	}

}


sub FetchAndShow {

	my( $source ) = @_;
	open( IN, $source ) or die "Couldn't find the file $source! Error: $!";
		while( <IN> ){
			print "$_\n";
		}
	close( IN );

}
